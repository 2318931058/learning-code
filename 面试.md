# Web

1. 编程思想。

   ```
   1. 面向对象：把事物分解为一个个对象，然后由对象之间分工合作。其优点是易维护、复用和扩展，缺点是性能比面向过程低。
   2. 面向过程：分解出解决问题所需的步骤，然后用函数把这些步骤一步一步的实现，使用时再依次调用这些函数。优点是性能比面向对象高，缺点是不易维护和复用。

2. 跨域问题。

   ```
   跨域就是指浏览器不能执行其它网站的脚本。
   
   // 解决方式
   1. jsonp

3. HTTP状态码有哪些？

   ```

4. HTTP协议和HTTPS协议的区别。

   ```
   1. http是超文本传输协议，信息是明文传输，连接是无状态的。https采用ssl加密传输，比http更安全。
   2. 二者连接的端口不一样，http的端口是80，https的端口是443。
   3. http需要到ca上申请证书，可能要花费一定的费用。

5. 前端页面的组成及各个组成部分的作用。

   ```
   1. 结构：对应html，用于构建标签。
   2. 表现：对应css，用于美化页面。
   3. 行为：对应js，用于触发事件。
   ```

6. 谈谈你对Web标准和W3C规范的理解。

   ```
   1. 标签字母要小写。
   2. 标签要闭合。
   3. 标签不允许随意嵌套。
   4. 尽量使用外联css和js。
   ```

7. SEO如何优化？

   ```
   SEO也就是搜索引擎优化，其方式有
   1. 服务端渲染SSR。
   2. 预渲染插件：prerender-spa-plugin。
   ```

8. 软件架构模式有哪些？区别是什么？

   ```
   // mvc和mvvm都是软件架构模式，用于设计和组织应用程序中的代码。它们的主要区别在于它们的角色分配和交互方式。
   1. mvc模式将应用程序分为模型model、视图view和控制器三种。其中，模型表示数据和业务逻辑，视图表示用户界面，控制器则充当模型和视图之间的协调者，负责用户的输入、更新模型和更新视图等。视图和控制器之间通过事件驱动进行交互，控制器响应事件后进行模型和视图的更新。
   2. mvvm模式将应用程序分为模型model、视图view和视图模型viewModel三部分。其中，模型表示数据和业务逻辑，视图表示用户界面，而视图模型充当模型和视图之间的协调者。视图模型通过数据绑定将模型中的数据和视图中的控件绑定在一起，使得当模型中的数据发送变化时，视图能够自动更新。
   ```

# GIS

1. 天地图是什么？如何加载？

   ```
   天地图是由中国国家测绘局发布的一套在线地图服务，用于发布中国地图相关数据。这种数据是以标准的web地图瓦片格式提供，包括矢量地图和瓦片地图。
   
   // 加载方式
   1. 访问天地图官网，取得令牌，获取访问资格。
   2. 选取合适的服务，获取其url。
   3. 选择合适的地图框架，创建一个带有宽高的地图容器。
   4. 初始化地图服务，加载服务，设置其url等属性。
   5. 添加用户交互功能，提升用户体验。
   
   天地图的地理坐标系为WGS84，投影坐标系为墨卡托/高斯-克吕格。使用时需要先将WGS84转换为墨卡托/高斯-克吕格，然后才能在地图上显示
   ```

2. GIS的基本功能。

   ```
   GIS是随地理科学、信息技术、遥感技术和计算机技术的发展而产生的一门新兴学科。就其应用而言，是对地理数据的采集、编辑、存储和展示，其本质上探讨的是坐标问题。其基本功能有：
   1. 数据的采集、监测和编辑。
   2. 数据的处理与变换。
   3. 数据的存储与组织。
   4. 空间查询与分析。
   5. 图形交互与展示。

3. WebGIS是什么？当前的研究热点有哪些？

   ```
   webgis是一种基于web技术的地理信息系统，它将地理空间数据及其相关信息整合到一个页面或应用程序中，使用户可以浏览和查询地理空间数据，发现其发展规律。
   
   // 研究热点
   1. 大数据与webgis的结合：大数据给webgis带来的更多的数据源和分析方法，如何将大数据与webgis相结合，使webgis具有更加强大的分析能力，是当今国际的一个研究热点。
   2. webgis的移动化与无线化。

4. 地图三要素是什么？

   ```
   1. 比例尺：1:1000表示图上一厘米，现实1000厘米。
   2. 指南针
   3. 图例

5. 地图投影是什么？

   ```
   地图投影就是将地球表面的三维曲面投影到二维平面上的方法。

6. 动态投影是什么？

   ```
   在GIS中，动态投影就是指实时地、可视化地展示地理空间数据地技术。它将地理空间数据映射到屏幕上，并动态地展示地理空间数据在各个时间点的变化，从而帮助人们分析变化趋势，以便更好地做出决策。

7. 投影的类型有哪些？

   ```
   1. 等角投影：角度不变，但面积和距离会发生不同程度的改变，如墨卡托投影。
   2. 等距投影：距离不变，但角度和面积会发生变化，如兰伯特投影。
   3. 等积投影：面积不变，但角度和距离会发生改变，如高斯-克吕格投影。

8. 常用的坐标系有哪些？

   ```
   1. 地理坐标系：用经纬度表示地球上点的位置，单位为度，多用于导航和定位。
   	* 北京54
   	* 西安80：参考椭球为IAG1975椭球，坐标原定为陕西西安泾阳县永乐镇。
   	* CSGCS2000：也称大地坐标系，参考椭球为克拉索夫斯基椭球，坐标原点为地球质心。多用于中国境内的地理制图。
   	* WGS84：参考椭球为WGS84椭球，坐标原点为地球质心。多用于定位和导航。
   2. 投影坐标系：将地球表面的三维曲面投影到二维平面上的坐标系，单位为米，多用于制图和测量。
   	* UTM投影：将地球分为多个投影区域，减少了跨区域的扭曲。可用于局部地区的测量和导航。
   	* 墨卡托投影：是一种等角圆柱投影，将地球表面投影到一个二维平面上，使经纬度形成规则的网格。多用于在线地图。
   	* 高斯-克吕格投影：将地球分为多个狭窄的带状区域，每个带状区域采用不同的参数，因而经度比较高。多用于制图和测量。
   	* 兰伯特投影：是一种等距圆锥投影，多用于中纬度地区的制图。
   	* 极坐标投影：以南北极点为中心，将地球投影到一个圆上，但在赤道区域出现扭曲。多用于极地地区的制图。
   3. 像素坐标系：也就是屏幕上的坐标。以左上角为原点，向右/下为正。多用于图像处理。
   4. 瓦片坐标系：将地图数据划分为瓦片的坐标系统，每个瓦片都有唯一的标识。多用于在线地图中。
   
   // gcj-02和墨卡托投影的区别
   1. 墨卡托是投影坐标系，单位为米；gcj-02是地理坐标系，单位为度。
   2. 墨卡托投影投影到二维平面上后形状是规则的网格，但gcj-02更为自然。
   3. 墨卡托投影多用于世界地图，gcj02多用于中国境内。

9. 简要介绍以下OGC服务。

   ```
   OGC的全称是开放地理空间信息联盟，是一个非盈利的国家化组织，为地理空间数据制定了一系列的服务和标准，主要包含以下几个方面：
   1. WMS地图服务：用于获取地图图像。
   2. WFS矢量服务：用于获取地理空间数据。
   3. WCS影像服务：用于获取遥感影响的等栅格数据。
   4. WMTS瓦片服务：用于获取瓦片数据。
   5. WPS网络处理服务：用于提供地理空间处理功能。

10. WMS和WMTS的区别。

    ```
    1. WMS是基于‘请求-相应’的数据传输模式。每次请求数据时，服务器都会动态生成新的地图图像，并将整张地图图像返回给客户端。客户端收到响应后，再将地图渲染到页面中。WMTS是基于‘瓦片数据’的数据传输模式。地图数据会被切割成瓦片存储在服务器上，并在服务器上预加载。用户可以通过url获取特定级别的瓦片，并将其渲染在页面中。
    2. WMS的影像是动态生成的，所以比较灵活。但每次请求都会生成新的地图图像，故速度会比较慢，且需要客户端自行处理缓存。而WMTS的影像是瓦片数据，是静态的，天然适合缓存，故用户可以直接从缓存中加载影像，速度较快。

11. 空间分析有哪些方法。

    ```
    空间查询、空间统计、空间插值、空间模型、空间决策

12. 什么是空间元数据？

    ```
    空间元数据是指用于描述空间数据的质量表示方法、空间参考和管理方法的数据，是实现空间数据共享的核心标准之一。
    ```

13. 什么是空间数据引擎？

    ```
    空间数据引擎是应用程序和空间数据库之间的一种中间件技术，为用户访问空间数据库提供了统一的接口。
    ```

14. 栅格切片是什么？需要设置哪些参数？

    ```
    栅格切片是指将一个大的栅格数据集切割成若干个小的栅格数据集的方法，以便存储、管理和分析。
    
    参数：切片方式、切片大小、切片编号、坐标系、输出路径、压缩格式

15. 切片层级是什么？有哪些优势？如何进行切分？

    ```
    切片层级是指将地图数据切割成若干个等级的方法，每个级别包含一组预定义大小的瓦片。
    
    优势：提升性能、优化内存
    
    切分步骤：
    1. 确定每个瓦片的大小。
    2. 定义不同的缩放级别，确定每个级别下的地图投影和坐标范围。
    3. 在服务器端将地图数据切割成不同级别的瓦片。
    4. 客户端请求数据，渲染页面。

16. 切片地图服务和动态地图服务的区别。

    ```
    动态地图服务是一种基于矢量数据的地图服务，每次请求时服务器都会动态生成新的地图图像，然后将其返回给客户端，因此加载速度会比较慢。切片地图服务是一种基于瓦片数据的地图服务，地图数据被切割成瓦片存储在服务器上，并在服务器上预加载，用户可以根据url请求特定级别的瓦片，加载速度比较快。
    ```

# Map

## Cesium

1. Cesium的基本功能。

   ```
   Cesium是一款3D的地球可视化引擎，可以在页面上渲染高度真实的地球场景。它提供了多种漫游和导航方式，支持各种地形和影像数据格式，也支持3D Tiles、GLTF等技术，可以用于虚拟现实、实时定位追踪等领域。

2. Cesium中有哪些坐标系？

   ```
   世界坐标系cartesian3、地理坐标系、屏幕坐标系cartesian2，默认坐标系为世界坐标系

3. Cesium中的坐标转换。

   ```
   // 经纬度坐标转为世界坐标
   Cesium.Cartesian3.fromDegrees(lon, lat, height)
   
   // 经纬度转为屏幕坐标
   Cesium.Cartesian3.fromDegrees(lon, lat, height)			// 先转为世界坐标
   Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, cartesian3)		// 再转为屏幕坐标
   
   // 世界坐标转为经纬度坐标
   Cesium.Cartographic.fromCartesian(cartesian3)		// 先转为弧度
   Cesium.Math.toDegrees()								// 再转为经纬度

4. Cesium中拾取坐标的几种方式。

   ```
   1. 鼠标拾取：Cesium.viewer.scene.pick
   2. 键盘拾取
   3. 空间拾取：Cesium.viewer.scene.pickPosition
   4. 图元拾取

5. Cesium支持哪些数据类型和数据模型？

   ```
   // 数据模型
   地形、模型、图层、标记、实体、图元、相机、矢量数据、栅格数据
   
   // 数据类型
   1. 3D Tiles：Cesium在2016年定义的一种3D模型的地理空间数据结构，以分层分块的形式组织和存储数据，能够大大减轻浏览器和cpu的负担，目前已是OGC标准之一。
   2. GLTF：是一种用于在webgl等图形api中描述和渲染动态地图场景的开放标准。
   3. GeoJSON：是一种基于JSON格式的空间数据结构，将地理空间数据与非空间属性信息进行编码，并以JSON格式进行存储，可用来描述点线面等地理要素，也可用来加载3D模型等。
   4. KML：是一种用于标记和呈现地图数据的xml格式数据，如加载3D模型和标记等。
   5. CZML：是一种描述和渲染动态地图场景的数据格式，包括物体的位置和方向等信息，通常用来表示物体的运动轨迹等。
   6. OBJ：是一种广泛应用的3D图形格式，可以用来描述点线面等三维网格几何信息。

6. GLTF和GLB的区别。

   ```
   gltf既可以是自包含的，也可引入外部二进制资源和纹理资源。
   
   glb只能是自包含的。
   
   可以说：glb是gltf的一个压缩版本

7. 如何处理3D Tiles飘在空中的问题？

   ```
   1. 确保3D Tiles数据中有高程信息。
   2. 检查坐标系是否相符。
   3. 配置地形提供者。
   4. 开启贴地属性和设置高度偏移。

8. Cesium中如何加载天地图的地形数据？

   ```
   1. 从天地图获取地形数据的URL。
   2. 通过TerrainProvider类配置地形提供者。

9. Cesium中如何修改GeoJSON格式数据的颜色？

   ```
   1. 通过GeoJSONDataSource类添加geojson数据。
   2. 通过entities.values获取所有实体。
   3. 遍历获取到的实体，根据不同的实体对象判断颜色属性，修改其属性值即可。
   ```

10. 简要介绍Cesium中的相机。

    ```
    Cesium中的相机就是视图在场景中的位置，包括destination属性和orientation属性，orientation又分为偏航角heading、俯仰角pitch和翻滚角roll。同时，相机还可以通过setView、flyTo和lookAt等方法设置视角的位置。

11. Cesium中的类有哪些？它们的作用是什么？

    ```
    1. ImageryProvider类：加载地图影像图层。
    2. TerrainProvider类：构建地形。
    3. dataSource类：加载数据。

12. Cesium中如何更换图层？

    ```
    // 添加图层
    viewer.imagerLayers.addImageryProvider(layer)
    
    // 删除图层
    1. 获取图层：viewer.imageryLayers._layers[index]
    2. 删除图层：viewer.imageryLayers.remove(layer)

13. Cesium中如何加载圆、飞线、柱状图？

    ```
    // 圆
    viewer.entities.add添加Circle实体。
    
    // 飞线
    1. viewer.entities.add添加Polyline实体。
    2. 计算带有弧度效果的点集数组作为position属性的值。
    3. 若要实现飞线效果：创建自定义材质类和shader实现。
    
    // 柱状图
    1. viewer.entities.add添加box实体，并开启贴地属性。
    2. 若要实现动态效果：创建sampledProperty实例对象，调整各个时间点对应的值，将赋值好的samplePosiitonProperty赋值给destination

14. Cesium中实体和图元的区别。

    ```
    1. 实体是Cesium中重要的图形概念，可以用来描述具有实际位置的物体，如飞机等。每个实体都有不同的属性，如position等，并且可以进行添加、修改和移除。与图元相比，实体是更高层次的概念，所以它可以处理许多与底层和几何形状相关的复杂性，并且可以与Cesium的许多插件相集成，如相机控制等。
    2. 图元是cesium中3D渲染的基本单元，可以用来描述几何物体和纹理资源。由于它是比实体更低的图形概念，故多用来描述一组简单的几何体。图元的优势在于它更高效，因为它使用了GPU加速，因此可以轻松绘制大量图形。同时，它也比实体更加灵活，因为它能更好地控制几何体的属性和细节。
    3. 总之，实体和图元都是cesium中重要的图形概念，只是它们的应用场景不同。若要构建具有复杂对象的几何体，那就用实体。若要构建简单的几何体，那就用图元，因为它可以进行更好地细节控制和提高性能。

15. Cesium中图元有哪些应用场景？

    ```
    1. 渲染几何体：图元可以用预定义几何类，如boxGeometry，渲染简单的几何体；用三角网格triggleMeshGeometry渲染复杂几何体。
    2. 纹理资源：图元可以被映射到各种几何体上，以便创建更加真实的地图场景。
    3. 映射：图元可以被映射到各种地形上，也就是说在不同的地形上显示相同的场景，提高可视化效果。
    4. 地图上有很多要素时使用图元绘制会大大提高效率。

16. Cesium中如何加载粒子效果？

    ```
    1. 使用new Cesium.ParticleSystem创建粒子对象，并设置image、speed、emitter等属性。
    2. 通过viewer.scene.primitives.add将其添加到场景中。

17. Cesium中如何加载弹窗？

    ```
    1. 使用new Cesium.ScreenSpaceEventHandler创建事件对象，并通过setInputAction方法注册点击事件。
    2. 通过viewer.scene.pick方法获取到一个包含点击位置和被拾取实体对象的对象。
    3. 根据拾取到的实体信息，创建自定义弹窗，最后通过Cesium.viewer.Infobox将其渲染到视图中。

18. Cesium的标注问题。

    ```
    // 如何加载标注
    通过viewer.entities.add方法添加billboard实体，然后设置position等属性即可。
    
    // 标注模糊应该如何解决
    1. 调整标注的距离和大小。
    2. 给标注设置样式，如边框和背景色等。

19. 加载的数据模型过大怎么处理？

    ```
    1. 使用专业的建模软件，如blender等，通过弱化细节等方式减小模型大小。
    2. 将模型进行分块处理，每次只加载可视范围内的块。
    3. 通过LOD技术，根据距离等条件使用不同分辨率的模型代替原始模型。
    4. 将数据格式转为gltf(一般来说，gltf格式的数据要比其它格式的数据要小)。
    ```

20. 二维和三维的区别。

    ```
    二维和三维最主要的区别就是它们描述的维度不同。
    1. 二维指的是平面，通常用两个坐标轴描述图像或平面几何，如一张地图等。
    2. 三维指的是空间，通常用三个坐标轴描述物体或物体的几何形状，如一架飞机等。

21. Cesium和MapBox的区别。

    ```
    1. mapbox的定位是静态地图和动态地图的制作，为移动端和web端提供了强大的地图渲染引擎和渲染工具。而cesium更注重实景地球的渲染，主要用于虚拟现实和实时定位追踪等方面。
    2. mapbox虽然可以使用openStreet等提供的开源数据，但更多的数据是来源于其开发者社区。而cesium的数据来源于BingMap等开源服务商。
    3. mapbox主要通过JS等web技术加载，而cesium主要通过webgl渲染。

## Openlayers

1. Openlayers中的类有哪些？

   ```
   map、view、layer、source、style、projection、overlay、controls、mapEvent
   ```

2. Openlayers如何加载栅格服务？

   ```
   1. 使用new ol.source.tileWMS创建source，并设置其url和projection等属性。
   2. 通过new ol.layer.tile创建layer。
   3. 最后通过map的addLayer方法将服务添加到地图中。
   ```

3. Openlayers中如何加载WMTS服务？

   ```
   // 方式一：使用new ol.source.WMTS加载，需要设置坐标原点、分辨率数组和坐标系参数等。
   
   // 方式二：使用new ol.source.XYZ加载，需要设置url、xyz和坐标系。
   ```

4. Openlayers支持哪些数据格式？

   ```
   geojson、topjson、WMS、WMTS等
   ```

5. Openlayers中如何转换坐标？

   ```
   1. 使用new ol.proj.projection指定目标坐标。
   2. 通过ol.proj.transforms转换坐标。
   ```

6. Openlayers中如何将图层添加到指定位置？

   ```
   1. 通过map.getLayers获取所有图层。
   2. 通过insertAt方法将其添加到指定位置。
   ```

7. 地图上要素很多，页面加载很慢如何处理？

   ```
   1. 通过过滤等方式优化数据，仅保留必要的属性和信息，减小数据大小。
   2. 使用瓦片地图，每次只加载可视范围内的地图。
   3. 使用图层分级技术，将图层划分为若干个等级，每个等级只保留某类要素，减少每次加载要素的数量。
   4. 通过缓存、预加载等技术优化前端性能，如将经常使用的数据保存在浏览器中。

8. 前端页面如何实现矢量服务和影像服务的叠加？

   ```
   1. 选择合适的地图框架和获取对应服务的url地址。
   2. 初始化地图服务，创建地图容器和加载对应服务。
   3. 通过设置图层的透明度和堆叠顺序等属性实现矢量服务和影像服务的叠加。

9. Openlayers和Leaflet的区别。

   ```
   1. openlayers发布于2006年，目标是提供一个高度自定义的地图库，用户可以在社区内找到各种插件和扩展实现需求。leaflet发布于2011年，目标是提供一个适用于快速开发的轻量级地图库。
   2. openlayers的配置项多，api复杂，可以精细地控制地图外观，适合于构建复杂的地图应用。leaflet配置项简单，api更注重易用性，通常使用css代码控制地图外观，适合于快速构建地图应用。
   3. openlayers支持webgl渲染，可以快速加载大规模数据集。leaflet虽然也可以加载，但在速度和性能上不如openlayers。
   ```

# Font

## Vue

1. Vue2和Vue3的区别。

   ```
   1. 使用组合式api代替选项式api。
   2. 一些细节上的使用发生改变：没有了this、生命周期变化、v-if和v-for优先级变化、根实例的创建、全局方法的挂载······
   3. 使用proxy代替defineProperty，可以监听所有对象，解决了数组无法通过下标修改等问题。
   4. vue3中增加了静态节点标记，不再对静态节点进行比对，从而提升了性能。
   5. vue3中v-model绑定的事件和值发生改变。
   6. vue3中使用hook函数进行逻辑复用。
   7. vue3更好地支持ts。

2. vue3的性能为什么比vue2好？

   ```
   1. diff算法优化： vue3中增加了静态节点标记，不再对静态节点进行比对，从而提升了性能。
   2. 静态提升：没有参与更新的元素只会创建一次，可以直接复用。

3. vue3中proxy的优势。

   ```
   1. defineProperty只代理对象上的某个属性，proxy可以代理整个对象。
   2. defineProperty不能监听对象新属性的定义和函数调用的一些操作，proxy可以（对代理对象的监听更加丰富）。
   3. defineProperty会修改代理对象本身，proxy代理对象会生成新的对象，而不会修改代理对象本身。
   4. proxy不兼容ie浏览器。

4. Vue3中Setup语法糖的优势。

   ```
   1. 代码更加简洁。
   2. 更加清晰的逻辑分离。
   3. 更好地性能：setup语法糖可以更好地利用proxy，提升组件性能。

5. v-if和v-for的优先级在Vue2和Vue3中有什么变化？二者可以一同使用么？

   ```
   1. 变化：vue2中v-for的优先级高，vue3中v-if的优先级高。
   2. vue2中不可以。vue3中可以，但官方不推荐一同使用。
   ```

6. ref和reactive的区别。

   ```

7. route和router的区别。

   ```

8. 强制刷新的方法。

   ```
   1. location.reload()方法。
   2. history.go(0)方法。
   3. this.$router.go(0)方法。

9. 路由懒加载的几种方式

   ```
   1. 异步加载：component: resolve => require(['../pages/home/problemList'], resolve)
   2. import加载：component: () => import('路径')
   3. webpack提供的require.ensure()加载：component: resolve => require.ensure(['路径'], resolve(require('路径')))
   ```

10. vue和jquery的区别。

   ```
   1. 原理不同：vue是数据绑定，jquery是先获取dom再处理。
   2. 着重点不同：vue是数据驱动，jquery是着重于页面。
   3. 操作不同：vue会自动更新dom，jquery需要先获取dom再进行处理。
   4. 未来发展趋势不同：vue是一个框架，使用量在增加；jquery是一个js库使用量再在减少。

11. 简要描述diff算法和虚拟DOM。

    ```
    1. 虚拟DOM：利用js描述元素间关系的一种结构，需要创立的一个JS对象。组件内的响应式数据发生改变时，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的DOM内容，然后去对应的真实DOM中修改。
    2. diff算法：就是虚拟DOM进行比对时的一种方法，返回一个patch对象。这个对象的作用就是存储两个节点不同的地方，最后用patch中记录的信息更新真实DOM。其具体步骤是：
    	* JS对象表示真实的DOM结构，要生产一个虚拟DOM。再用虚拟DOM更建一个真实DOM树，渲染到页面。
    	* 状态发生改变时会生成新的虚拟DOM，将其与旧的虚拟DOM进行比对，这个比对的过程就是diff算法，利用patch记录差异。
    	* 把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了。

12. vue的双向数据绑定原理是什么？

    ```
    通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的setter和getter，在数据发生改变的时候发布消息给订阅者，出发对应的回调渲染视图。也就是说数据和视图是同步的，数据发生改变，视图跟着发生变化；视图改变，数据也会发生改变。具体的步骤是：
    1. 需要对observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter。
    2. Compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图。同时把每个指令对应的节点绑定上更新函数，添加订阅者。若数据发生变化，视图也会更新。
    3. watcher订阅者是Observer和Compile之间的通信桥梁，作用是在自身实例化的时候往订阅器中添加自身，等待属性变动时，调用自身的update方法，触发Compile的回调。
    4. MVVM作为数据绑定入口，整合了observer、compile和watcher三者，通过observer来监听自身的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图，视图更新数据的效果。
    ```

13. vuex的响应式处理。

    ```
    1. vuex是vue的状态管理库，其state是响应式的，可以借助vue的data，将state存到vue实例组件的data中。
    2. vuex不能像vue直接触发methods中的方法，在处理异步事件的时候，需要通过dispatch访问actions中的方法，actions中的commit会触发mutations中的方法，从而修改state的值，最后再通过getters更新视图。
    3. 可以通过vue.use方法将vuex绑定到vue中，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store访问store对象。

14. vuex属性有哪些？会在什么场景中使用？

   ```
   // 属性
   1. state用于存储变量。
   2. getters是state的计算属性。
   3. mutations是提交更新数据的方法。
   4. actions提交mutations来修改数据，可以是异步操作。
   5. modules是模块化vuex。
   
   // 使用场景
   存储用户的个人信息、购物车模块、订单信息等
   ```

15. 如何封装组件？需要满足什么条件？

    ```
    // 封装组件
    1. 使用vue.extend()创建一个组件。
    2. 使用vue.components()方法注册组件。
    3. 若子组件需要修改数据，可以在props中接收定义。
    4. 用emit()方法接收子组件传递给父组件的数据。
    
    // 条件
    1. 低耦合：组件之间的依赖越小越好。
    2. 最好从父组件传入信息，不要在公共组件中请求数据。
    3. 传入的 数据要进行校验。
    4. 处理事件的方法写在父组件中。
    ```

16. vue的过滤器如何使用？

    ```
    过滤器是vue的一个特性，可以用来对文本进行格式化处理。主要用于插值表达式和v-bind。包括：
    1. 全局过滤器
    	Vue.filter('add', function(item){
    		return item < 10 ? '0' + item : item
    	})
    	<div>{{22 | add }}</div>
    2. 本地过滤器：和methods同级
    	filter: {
    		add:function(item){
    			return item < 10 ? '0' + item : item
    		}
    	}
    	<div>{{22 | add }}</div>
    ```


15. 怎么优化性能？首页优化该怎么做？

    ```
    // 性能优化
    1. 编码优化：keep-alive缓存组件、尽可能拆分组件提高复用性、数据持久化时使用防抖和节流、合理使用路由懒加载和异步组件等。
    2. 加载优化：按需加载、内容和图片懒加载。
    3. 用户体验：骨架屏。
    4. SEO优化：预加载、服务端渲染SSR。
    5. 打包优化：CDN形式加载第三方模块、多线程打包、抽离公共文件。
    6. 缓存和压缩：客户端缓存、服务端缓存、服务端Gzip压缩。
    
    // 首页优化
    1. 路由懒加载。
    2. 非首页的组件使用异步组件。
    3. 首页中不重要的组件延迟加载。
    4. 静态资源放在CDN上。
    5. 减少首页中JS、CSS等资源文件的大小。
    6. 图片懒加载、使用精灵图请求。
    7. 开启Gzip压缩。
    8. 尽量减少DOM的数量和层级。
    ```

16. 对组件的理解。

    ```
    1. 可以重复使用的vue实例，具有独一无二的组件名称。
    2. 可以抽离单独的公共模块，提高代码的复用率。

17. 是否用过nuxt.js？

    ```

## CSS

1. 对BFC的理解。

   ```
   1. 概念：bFC是块级格式化上下文，是页面上一个隔离的独立容器，容器内的子元素不会影响到外面的元素。
   2. 原则：若一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
   3. 如何触发：float非none、overflow非visible、display为inline-block等、position为absolute、fixed。

2. sprite是什么？有什么优缺点？

   ```
   1. sprit是雪碧图，又称精灵图，是把多个小图标合并成一张大图片。
   2. 优点：减少了http请求次数，提升性能。
   3. 缺点：需要计算位置，且不易维护（如图片位置修改等）。

3. 重绘和回流。

   ```
   // 回流一定会造成重绘，重绘不一定会造成回流。
   1. 重绘
   	* 概念：
   	* 场景：样式改变，如color、background等。
   2. 回流
   	* 概念：
   	* 场景：改变元素的位置、显示\隐藏元素等。

4. CSS3有哪些新特性？

   ```
   文本阴影、盒子阴影、弹性盒子、圆角边框、transform、transition

5. CSS中的常见单位有哪些？

   ```
   px、百分比、em、rem、vw\vh、vmax\vmin

6. CSS中的布局方式有哪些？

   ```
   弹性盒子flex、网格布局grid、浮动float、定位position

7. position有哪些属性？分别是根据什么定位的？

   ```
   1. static：默认，无定位。
   2. fixed：固定定位，相对于浏览器窗口进行定位。
   3. relative：相对定位，相对于自身定位，不脱离文档流（right和bottom不生效）。
   4. absolute：绝对定位：相对于第一个有relative的父元素，脱离文档流。

8. display有哪些属性？作用是什么？

   ```
   1. none：隐藏元素
   2. inline-block：转为行内块
   3. block：转为块元素
   4. inline：转为行内元素
   5. table：转为表格形式显示

9. 如何使用CSS清除浮动？

   ```
   1. 触发BFC
   2. 额外标签法：给父元素内部添加一个块元素，然后给父元素设置clear:both;
   3. 单伪元素清除：给父元素添加
   .clearfix::after {
       content: '';
       display: block;
       clear: both;
   }
   4. 双伪元素清除：给父元素添加
   .clearfix::before, .clearfix::after {
       content: '';
       display: table;
   }
   
   .clearfix::after {
   	clear: both;
   }
   5. overflow：hidden;

10. CSS中选择器有哪些？优先级如何计算？

   ```
   // 选择器（内联样式权重值为1000）
   1. 通配符选择器：权重值为0
   2. 标签选择器：权重值为1
   3. 类选择器：权重值为10
   4. id选择器：权重值为100
   5. 相邻选择器
   6. 后代选择器
   7. 子元素选择器
   8. 属性选择器
   9. 伪类选择器
   10. 伪元素选择器
   
   // 优先级
   !import > id选择器 > 类选择器 > 标签选择器 > 通配符选择器

11. CSS的样式继承问题。

    ```
    1. css中可以继承的样式一般为文字相关样式，如color、font-size、line-height、text-align等，还有opacity。
    2. css中不可继承的样式有margin、padding、border、position等。

12. 元素隐藏的方式有哪些？它们之间的区别是？

    ```
    1. display:none;隐藏不保留位置；会导致重绘和回流。
    2. visibility:hidden;隐藏保留位置；只会导致重绘，不导致回流；不触发绑定的事件。
    3. opacity:0;隐藏保留位置；会出发绑定的事件。

13. 如果图片在div中有缝隙，应该如何解决？

    ```
    // 方式一：给图片添加font-size:0;
    // 方式二：给div添加verticle-align:bottom;

14. CSS的盒模型。

    ```
    css的盒模型有两种，二者可以通过box-sizing属性进行转换
    1. 标准盒模型content-box：content、border、padding、margin
    2. IE盒模型border-box：margin + content（border + padding + content）

15. 如何实现水平垂直居中？

   ```
   1. 弹性盒子布局。
   2. 网格布局。
   3. transfrom + 定位。
   4. margin + 定位。
   5. 修改display属性为inline-block，给父元素添加line-height属性和text-align属性。

16. 用css绘制三角形。

    ```css
    /* 可以使用边框进行绘制：哪边为底，哪边有颜色，其余边框为透明色。 */
    div {
        width: 0;
        height: 0;
        border-left: 100px solid transparent;
        border-right: 100px solid transparent;
        border-top: 100px solid transparent;
        border-bottom: 100px solid #ccc;
    }

17. 双飞翼布局。

    ```html
    <!DOCTYPE html>
    <html lang="en">
    
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>双飞翼布局</title>
        <style>
            * {
                padding: 0;
                margin: 0;
            }
            .container {
                width: 100vw;
                height: 100vh;
            }
            .container > div {
                float: left;
            }
            .left {
                margin-left: -100%;
                width: 200px;
                height: 100%;
                background-color: red;
            }
            .center {
                width: 100%;
                height: 100vh;
                background-color: green;
            }
            .right {
                margin-left: -200px;
                width: 200px;
                height: 100vh;
                background-color: blue;
            }
        </style>
    </head>
    
    <body>
        <div class="container">
            <div class="center"></div>
            <div class="left"></div>
            <div class="right"></div>
        </div>
    </body>
    
    </html>

18. link和@import的区别。

    ```
    1. 先有link，后有@important，且link的兼容性比@import好。
    2. 加载顺序不同：浏览器会先加载link，后加载@import。

19. height和line-height的区别。

    ```
    1. height是一个死值，就是盒子的高度。
    2. line-height是每一行文字的高度，若文字换行，则整个盒子的高度会增大（行高*行数）。

20. opacity和rgba的区别。

    ```
    opacity会继承父元素的opacity属性，rgba设置的元素的后代元素不会继承不透明属性。

21. CSS的预处理器有哪些？它们的区别是？

    ```
    css的预处理器主要有less和sass两种，它们的主要区别是：
    1. sass使用$定义全局变量，less使用@定义全局变量。
    2. sass支持条件语句循环语句，less不支持。
    3. sass引入外部css文件时需要以@开头，less无要求。
    4. sass的代码在服务端处理，less的代码在客户端处理。
    ```

18. 网页中的字体大小应使用奇数还是偶数？为什么？

    ```
    应该使用偶数，原因如下：
    1. 让文字在浏览器中更好看。
    2. ui给的设计图一般都是偶数的，为了方便布局和转换，使用偶数会更方便。

## HTML

1. HTML5有哪些新特性？

   ```
   canvas画布、video、audio、语义化标签head等、地理定位接口、网络访问接口等

2. HTML中有哪些标签？

   ```
   1. 行标签：span、a、audio、strong、label、em、del等。
   2. 块标签：div、h1~h6、p、ul、li、tr、th、td等。
   3. 行内块：input、textarea、img、button、video等。
   4. 其他标签：hr、br、语义化heading等。
   ```

3. title和h1、b与strong、i与em的区别？

   ```
   // title和h1
   1. title是网页标题，概括了网站信息，可以告诉搜索引擎\用户关于该网站的内容主题；
   2. h1是内容标题，用于告诉网站主要内容是什么，如：网站的logo一般使用h1包裹。
   3. 在SEO优化方面，title比h1更重要。
   
   // b与strong
   1. b是实体标签，用于给文字加粗效果，但没有实际含义。
   2. strong是逻辑标签，表示标签内的字符比较重要，用于强调语气。
   
   // i与em
   1. i是实体标签，用于做文字倾斜效果，但没有实际含义，主要用于字体图标方面。
   2. em是逻辑标签，表示标签内的字符比较重要，用于强调语气，主要用于某些专业术语方面，如医药等。

4. img标签的title属性和alt属性的区别。

   ```
   1. title属性是鼠标移入到图片显示的值，alt是图片无法加载时显示的值。
   2. 在SEO层面上，蜘蛛抓取不到图片的内容，所以为了增加SEO效果要加入alt属性来描述这张图是什么内容或关键词。

5. png、jpg、gif和webp的区别以及它们的应用场景。

   ```
   1. png：无损压缩，尺寸较大，适合做小图标。
   2. jpg：采用压缩算法，有点失真，比png体积小，适合做中大图片。
   3. gif：一般做动图。
   4. webp：同时支持无损和有损压缩，相同质量的图片，webp具有更小的体积，但兼容性不太好。

6. 如何理解HTML的语义化

   ```
   易于阅读和理解，方便浏览器解析

## Javascript

1. ES6新语法有哪些？

   ```
   let和const、箭头函数、模板字符串、promise、async\await、类、模块

2. let、const和var之间的区别。

   ```
   1. var可以重复声明，let和const不可以。
   2. var可以先使用，再声明，let和const不可以。
   3. var声明的变量可以挂载在全局对象window身上，let和const不可以。
   4. var没有块级作用域，let和const有。
   5. var有变量提升，let和const没有。
   6. var和let可以重新赋值，const不可以。

3. 箭头函数和普通函数的区别。

   ```
   1. 普通函数使用function进行定义，箭头函数使用()=>{}定义。
   2. 普通函数有this和arguments，箭头函数没有。
   3. 普通函数可以作为构造函数，箭头函数不可以。
   4. 普通函数需要return返回值，箭头函数的返回值是隐性的（只有一条语句不用return，多条语句必须return）。

4. Cookies、LocalStorage和SessionStorage的区别。

   ```
   1. 用途：Cookies用于身份令牌验证，localStorage用于长期存储用户首选项，sessionStorage用于临时存储数据。
   2. 持久性：Cookies指定时间、localStorage手动清除、sessionStorage浏览器关闭。
   3. 安全性：Cookies安全性低，localStorage和sessionStorage相对安全。
   4. 容量大小：Cookies存储容量小，localStorage和sessionStorage相对较大。

5. JavaScript的小数精度问题。

   ```
   1. 产生原因：JavaScript的Number类型数据在进行计算时，会将数值从十进制转换为二进制，但在转换的过程中，小数位数会出现无限不循环的情况，只能舍零入一，故而会发生小数精度丢失的问题。
   2. 解决方法：化整运算、toFixed()
   ```

6. 常用的数组方法有哪些？

   ```
   push、pop、unshift、shift、map、reduce、forEach、filter、flat、concat、slice、split、every、some、find、sort、reverse

7. 数组去重有哪些方法？

   ```
   [...new Set(arr)]、递归、sort、includes、双重for循环+splice

8. 数组的遍历方法有哪些？

   ```
   forEach、map、reduce、filter、findIndex、every、some

9. 字符串常用的方法有哪些？

   ```
   slice、substring、join、charAt、trim、startswith、match、search、concat
   ```

10. JavaScript中date是什么类型？字符串类型和倒叙类型哪个用的多？

   ```
   date是JavaScript中的一个内置对象，主要用的类型是字符串类型。

11. 简要介绍作用域和作用域链。

   ```
   1. 作用域是变量的可用性范围，可分为全局作用域和局部作用域。
   2. 作用域链本质上是底层变量的查找机制。当函数执行时，会先在当前作用域中寻找变量；若当前作用域中没有需要的变量，就会去最近一级的父作用域中查找；就这样一层一层地查找形成的链状结构就是作用域链。
   
   注意：优先级为：变量 > 函数 > 参数 > 变量提升
   var name = 'world';
       (function (){
       if(typeof name === 'undefined'){
       var name = 'jack'
       console.log(`goodbuy ${name}`)
       }else {
       console.log(`hello ${name}`)
       }
   })()

12. JavaScript中的垃圾回收机制与内存泄漏。

    ```
    JavaScript中内存的分配和回收都是自动完成的，不再使用的内存会被垃圾回收机制自动回收。但有时会出现内存无法回收或不再使用的内存没有得到及时释放的情况，这种情况就是内存泄漏，可以通过标记清除法和引用计数法解决。
    
    // 引用计数法：
    let person = {
        name:'佩奇',
        age:18
    }
    let p = person
    person = 1
    p = null
    
    // 标记清除法：从根部/全局对象出发，定时扫描内存中的对象。凡是能够从根部到达的对象，都是还需要使用的对象。若从根部出发无法触及到的对象被标记为不再使用，稍后会进行回收
    function fn(){
        let a1 = {}
        let a2 = {}
        a1.hobby = a2
        a2.friends = a1
    }
    fn()	// 用完这一次后，从根部就无法访问到了，就会被垃圾回收器进行回收。

13. 浅拷贝和深拷贝的区别。

    ```
    1. 浅拷贝拷贝的是地址：Object.assign或{...obj}拷贝对象，arr.prototype.concat(newarr)或[...arr]拷贝数组
    2. 深拷贝拷贝的是值：lodash库中的_cloneDeep方法、递归、JSON.strify和JSON.parse转换

14. 什么是原型，什么是原型链？

    ```
    1. 原型：每个函数身上都有prototype属性，这个属性就是原型对象。原型身上可以挂载一些变量和方法供全局使用。
    2. 原型链：每个对象身上都有__proto__属性，原型对象也是对象，也有__proto__属性，指向原型对象的原型对象。就这样一层一层地形成的链状结构就是原型链。
    
    // 笔试题
    function Foo(){
        getName = function(){
        	console.log(1)
        }
        return this
    }
    Foo.getName = function(){
    	console.log(2)
    }
    Foo.prototype.getName = function(){
    	console.log(3)
    }
    var getName = function(){
    	console.log(4)
    }
    function getName(){
    	console.log(5)
    }
    
    Foo.getName()           // 2
    getName()               // 4
    Foo().getName()         // 1
    getName()               // 1
    new Foo().getName()     // 3

15. 什么是重绘？什么是回流？

16. 什么是防抖，什么是节流，它们如何实现？

    ```
    1. 防抖：单位之间内，多次触发事件，只执行最后一次，如搜索框输入。可以通过定时器和lodash库中的debounce方法实现。
    let timer - null
    document.querySelector('.inp').onkeyup = function(){
        if(timer !== null){
            clearTimeout(timer)
        }
        timer = setTimeout(()=>{
            console.log('防抖')
        }, 100)
    }
    
    2. 节流：单位之间内，多次触发事件，只执行第一次，如resize事件、scroll事件。可以通过定时器和lodash库中的throttle方法实现。
    let timer = null
    document.querySelector('.inp').onmouseover = function(){
        if (timer !== null){
            return 
        }
        timer = setTimeout(()=>{
            console.log('节流')
            timer = null
        }, 100)
    }

17. 什么是闭包？

    ```
    闭包就是一个函数与周围状态的引用捆绑在一起，内层函数中能访问到其外层函数的作用域。其作用是实现数据的私有。
    function fn(){
        let count = 1
        function func(){
            count++
            console.log(`函数被调用了${count}次`)
        }
        return fn()
    }
    const result = fn()
    result()		// 2
    result()		// 3

18. 什么是事件循环？

    ```
    JS的主要作用是操作dom和与用户交互，这就决定了JS必须是单线程的。但为了防止代码的阻塞，又把任务分为同步任务和异步任务。同步任务放在执行栈中，异步任务等待时机成熟放在任务队列中。当执行栈中的任务执行完毕后，js引擎会去任务队列中查看是否有任务，如果有，就拿到执行栈中执行，执行完再去任务队列中查看，有就再拿到执行栈中执行。就这样反复查看、执行的过程就叫做事件循环。

19. 宏任务和微任务的区别。

    ```
    1. 宏任务是由node环境和浏览器执行的任务，如定时器、事件、网络请求等。
    2. 微任务是由JS引擎执行的任务，如promise.then(catch)、async\await等。

20. This的指向问题。

    ```
    // 确定this指向
    1. 全局环境下（严格\非严格)都指向window。
    2. 局部环境下对象方法调用（严格\非严格)都指向调用者。
    3. 局部环境（严格）指向undefined。
    4. 局部环境（非严格）指向window。
    
    // 指定this
    1. 创建时指定用bind方法或箭头函数。
    2. 调用时指定用apply和call方法：call方法挨个传入参数，apply以数组形式传入参数。

21. 如何实现继承。

    ```
    ES6中用类实现继承，ES5中用原型实现继承

22. 事件委托是什么？应用场景有哪些？

    ```
    1. 事件委托就是指将一个/组元素的事件绑定到其父元素身上，以提高性能。
    2. 应用场景：根据传入的不同参数，跳转到不同的页面。
    ```

23. 简要介绍以下promise。

    ```
    1. promise是表示一个异步操作的最终结果和状态，包括pending、fulfilled和reject三种状态。
    2. promise后面可以.then处理resolve成功的回调，.catch处理reject失败的回调。
    3. promise的链式调用可以解决回调函数低于问题。
    4. promise的.all静态方法包含多个promise对象，只有当所有的promise对象都执行成功回调，promise.all静态方法才会执行成功回调，否则就执行失败的回调。
    5. 手写promise
    const p = new Promise((resolve, reject) => {
     // 成功调用: resolve(值) 触发 then() 执行
     // 失败调用: reject(值) 触发 catch() 执行
    })
    p.then(result => {
     // 成功
    }).catch(error => {
     // 失败
    })

24. null和undefined的区别。

    ```
    1. null表示变量没有指向任何对象，undefined表示一个未定义的值。
    2. 当使用==时，结果返回true，因为js会自动进行隐式转换；当使用===时，结果返回false，因为会判断类型。

25. JavaScript和TypeScript的区别。

    ```
    1. ts是一种强类型语言，必须在定义时就指明变量的类型；js是一种弱类型语言定义时不需要指明类型。
    2. ts在编译时会进行语法检查和类型检查；js只有在运行时才会进行检查。
    3. ts必须编译成js文件，才能在node环境或浏览器中执行；js可以直接在浏览器中运行。
    4. ts有js的全部功能，并且多了元组等js不具备的类型。
    ```

26. 统计字符串中每个字符的个数。

    ```javascript
    const str = 'aaabbbccccbbbaaaAAADDDEEE'
    
    function getNumber(str){
        let obj = {}
        for(i=0; i<str.length; i++) {
            let key = str[i]
            if(!obj[key]){
                obj[key] = 1
            }else {
                obj[key] += 1
            }
        }
        return obj
    }
    
    let res = getNumber(str)
    console.log(res)
    ```


27. 将URL中的参数解析为一个对象。

    ```javascript
    var url = 'http://witmax.cn/index.php?key0=0&key1=key1&key2=key2'
    
    function get(value){
        let obj = {}
        let url = value.split('?')
        let arr = url[1].split('&')
        arr.forEach(item => {
            var ans = item.split('=')
            obj[ans[0]] = ans[1]
        })
        return obj
    }
    
    let res = get(url)
    console.log(res)
    ```

    

## TypeScript

1. TypeScript中的泛型。

   ```
   泛型就是一种类型参数，在定义时不指明具体的参数类型，而是用字母代替；在使用时再通过特定的格式指明具体类型，可以大大增强便捷性。
   ```

2. TypeScript的数据类型有哪些？

   ```
   字符串、数值、布尔、undefined、null、对象、函数、数组、元组、根类型、枚举、接口、联合、交叉、泛型、类、void、any、never
   ```
   

# Node

1. 加密方式有哪些？

   ```
   1. Hashing：哈希是将任意长度的输入字符串转换为固定长度输出字符串的过程。Node.js提供了多种哈希算法，包括MD5、SHA-1、SHA-256等，这些算法可以用于数字签名、密码校验等场景。
   2. 加密算法：加密算法使得数据在传输过程中变得不可读，只有掌握密钥的人才能够读取数据。 Node.js提供了多种加密算法，包括对称加密算法、非对称加密算法等。对称加密算法包括AES、DES等，它们使用同一个密钥加密和解密数据。 非对称加密算法（如RSA）则使用一对公钥和私钥，加密和解密过程使用不同的密钥完成。
   3. Digital Signatures （数字签名）：数字签名是一种保证数据完整性和真实性的方法。它使用加密算法将数据哈希后生成的数字签名与数据一起传输，接收者使用相同的算法计算数据哈希，并验证数字签名的真实性。
   4. PBKDF2：PBKDF2是一个用于密钥派生的算法，它使用密码与一个随机的盐相结合，运行大量的迭代来生成密钥。
   5. bcrypt：bcrypt是一种密码哈希函数，它使用salt和cost factor的组合来确定哈希函数的强度。
   ```

# Extension

## Git

1. Git有哪些分布流，区别是什么？

   ```
   1. 集中式分布流：所有的开发人员都向同一个中央代码库提交代码。优点是简单，适用于小团队，缺点是中央代码库的故障可能会影响整个团队的工作。
   2. 分支式工作流：每个开发人员都有自己的分支，他们可以在自己的分支上进行开发，并在开发完成后将代码合并到主分支。优点是比较灵活，多人协作时不会相互影响，但需要比较严格的代码审核机制，以防止不良代码被合并到主分支上。

2. Git的常用命令有哪些？

   ```
   1. 初始化git仓库：git init
   2. 将本地代码提交到暂存区：git add .
   3. 将暂存区的代码提交到本地仓库：git commit -m '备注'
   4. 连接远程仓库：git remote add 远程仓库名称 远程仓库地址
   5. 查看已连接的远程仓库地址：git remote -v
   6. 将本地仓库的代码推送到远程仓库：git push 远程仓库名称 分支名称
   7. 拉取远程仓库的代码：git pull
   8. 克隆远程仓库的密码：git clone

## Echarts

1. 用过Echarts的哪些图表？这些图标有哪些组件？怎么分类型分数据的显示？

   ```
   ECharts中有柱状图、折线图、饼图、雷达图等，可以通过series属性转换图表类型，组件有：
   1. title：show、text、link
   2. legend
   3. tooltip：trigger、触发类型
   4. color
   5. grid
   6. series
   7. toolbox：导出图片、数据视图、切换、缩放、show、orient、feature
   8. radar
   9. markPoint标注点
   10. markLine图表的标线
   ```

## Request

1. 什么是AJAX，其原理是什么？

   ```
   1. AJAX是异步的JS和XML 。AJAX本身不是一种技术，而是一种将XMLHttpRequest对象等现有技术结合起来使用的方法。当使用了 AJAX 后，网页应用能够快速地将增量更新呈现在用户界面上，而不需要刷新整个页面。这使得程序能够更快地回应用户的操作。AJAX最吸引人的特性是它的“异步”性质，这意味着它可以与服务器通信、交换数据并更新页面，而无需刷新页面，即浏览器和服务器之间的动态数据交互。
   2. AJAX 的内部原理是XHR，即XMLHttpRequest对象，主要用于与服务器交互。通过XMLHttpRequest可以在不刷新页面的情况下请求特定 URL获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。其中，Axios内部采用XMLHttpRequest与服务器交互。
   ```

2. get和post的区别。

   ```
   1. get请求用于从服务器获取数据，post请求用于向服务器提交数据。
   2. get请求把数据放在url中，所以参数会保留在浏览器中。而post请求把参数放在请求体中，故post参数不会被保存。
   3. get请求的url长度在多数浏览器中都会被限制在2048字符内。post请求无相关限制。
   4. get请求的数据类型为ASCII， post请求无限制，可以为二进制。
   5. get请求可以被浏览器收藏为书签，post请求不行；get请求能被缓存，post请求不行。
   6. get请求时，浏览器会把请求头和数据一并发送，服务器响应 200，故只产生一个TCP数据包。post请求时，浏览器先发送请求头，在服务器响应成功后浏览器再发送数据，最后服务器返回数据，故会产生两个TCP数据包。

3. Axios如何取消请求？

   > 如果请求已经被发送并且正在等待响应，那么取消请求将不会有任何作用

   ```
   // 创建CancelToken实例
   const source = axios.CancelToken.source();
   
   // 将CancelToken实例传递给请求的cancelToken配置项
   axios.get('url', {
     cancelToken: source.token
   })
   
   // 当需要取消请求时，调用CancelToken实例的cancel()方法
   source.cancel('请求被取消');

4. 从输入URL到服务器响应，这期间发生了什么？

   ```
   1. URL解析：浏览器解析URL，确定请求的协议（例如：HTTP、HTTPS、FTP等）、主机名、端口号（如果有）和请求的路径。
   2. DNS解析：浏览器根据主机名查询DNS服务器，获取主机对应的IP地址。
   3. 建立TCP连接：浏览器向服务器发起TCP连接请求，如果连接成功，则可以进行数据传输。
   4. 发送HTTP请求：浏览器向服务器发送HTTP请求，请求中包括请求的方法（例如：GET、POST、PUT等）、请求头部（例如：Accept、User-Agent等）和请求体（例如：表单数据、JSON数据等）。
   5. 服务器处理请求：服务器接收到HTTP请求后，会根据请求的路径和方法处理请求，如果请求的资源不存在，则返回404错误；如果请求的方法不被允许，则返回405错误；如果请求的资源存在并且可以被访问，则返回200状态码，并返回响应数据。
   6. 服务器响应：服务器向浏览器发送HTTP响应，响应中包括响应头部（例如：Content-Type、Content-Length等）和响应体（例如：HTML页面、JSON数据等）。
   7. 浏览器解析响应：浏览器接收到HTTP响应后，会根据响应头部的Content-Type字段确定响应数据的类型，然后解析响应数据，并将其显示在浏览器中。
   8. 关闭TCP连接：浏览器关闭TCP连接，释放资源。

## Webpack

1. webpack打包和不打包的区别？

   ```
   打包后运行效率和对基础技术的支持都会提高。

2. webpack是怎么打包的？babel的作用是什么？

   ```
   // babel作用：将高级语法转为低级语法，供浏览器解析识别。
   
   // 打包过程
   1. 把js、css和image看做一个模块，用import/require引入。
   2. 找到入口文件，通过入口文件找到关联的依赖文件，把它们打包到一起。
   3. 把bundle文件，拆分为多个小的文件，异步按需加载所需要的文件。
   4. 若引用的文件没有调用，则不会打包。如果引入的变量和方法没有调用也不会打包。
   5. 若多个入口文件引入了相同的代码，可以用插件将其抽离到公共文件内。

# Arithmetic

1. 常用的排序算法有哪些?

   ```
   1. 冒泡排序是最基本的排序算法之一，每次比较相邻的两个元素，如果它们的顺序不对，就交换它们。这样一轮比较下来，最大的元素就会被排到最后面。然后再对剩下的元素进行相同的比较，直到所有元素都被排序。冒泡排序的时间复杂度为 O(n2)。
   2. 插入排序是将数组分为已排序和未排序两个部分，每次从未排序的部分中取出一个元素，插入到已排序的部分中，直到所有元素都被排序。插入排序的时间复杂度为 O(n2)。
   3. 快速排序是一种分治的排序算法，通过选择一个基准元素，将数组分为左右两部分，左边的元素都小于基准元素，右边的元素都大于基准元素，然后递归地对左右两部分进行排序。快速排序的时间复杂度为 O(nlogn)。
   4. 归并排序
   5. 堆排序
   ```
   
   # Other
   
   ## Non-Technology
   
   1. 你有什么优缺点？
   
      ```
      1. 优点：有自我驱动力，会在闲暇时间学一些新的技术。
      2. 缺点：有点焦虑。感觉别人都很优秀，如别人能够将学过的东西结合自己的理解进行整理复述，而自己在这方面比较欠缺。
   
   2. 你的职业规划是什么？

      ```
      1. 首先是通过公司的培训和自我学习，尽快熟悉和掌握该岗位所需要的技能。争取在一到两年内建立起对该行业的比较全面的认知，成为一名合格且专业的WebGIS开发工程师。
      2. 然后会考取相关的职业证书，不断学习新知识充实自己，优化自己的技能。同时，我会积极地参与公司的项目和活动，提高对公司的认同感。
      3. 在基础岗位能力得到一定的积累后，我希望能为公司发展做出更大的贡献，希望可以向管理层晋升，带领团队做出更好的成绩。
   
   3. 你的期望薪资是多少？
   
      ```
      
      ```
   
   4. 如果此次没有录用你，你会怎么办？
   
      ```
   
   5. 你的核心竞争力是什么？
   
      ```
      1. 比较有责任感。自己的工作一旦确定，就会全力以赴地完成好。同时，在生活中，身边的朋友也都觉得我比较靠谱，有事情需要帮忙也会来找我。
      2. 团队协作能力强。我是一个善于团队协作的人，能看到每个人的闪光点。如在之前实习的时候，我就能很好地发掘每个人的优势，协调好同事们之间的合作。
   
   6. 你能为公司带来什么？
   
      ```
   
   7. 毕业这么久了，为什么还没找到工作？
   
      ```
   
   8. 你手上还有没有其它的offer？
   
      ```
   
   9. 说说你在空窗期都做了什么？
   
      ```
   
   10. 你觉得你还有哪些欠缺的地方？
   
       ```
   
   11. 你缺乏岗位实际工作经验，如何胜任这份工作？
   
       ```
   
   12. 你学历有点低，你怎么看？
   
       ```
   
   13. 如果公司录用你，你将如何展开工作？
   
       ```
   
   14. 介绍一下你的家庭状况？
   
       ```
   
   15. 如何看待加班问题？
   
       ```
       
       ```
   
   ## Rhetorical
   
   1. 入职后的工作内容和使用的技术栈是什么？
   2. 项目是新开发的还是迭代之前的？
   3. 入职之后是否有免费培训？平时有什么学习机会么？
   4. 您对于我今天的表现怎么评价呢？有没有什么建议给到我去提升？
   5. 面试结果一般需要多久出来？
   6. 入职后多久签订劳动合同，是按照实际工资签订么？
   7. 劳动合同是几年的？试用期是多久？试用期期间工资是多少？转正的标准是什么？
   8. 工资结构是怎么构成的？基本工资和绩效的占比分别是多少？
   9. 是否有五险一金？公司和个人缴纳的比例各是多少？
   10. 是否有加班和出差的情况？加班或出差有没有补助？
   11. 工资是每月的几号发放？是否会延迟发放的情况？
   12. 上下班时间？休息时间？是否双休？